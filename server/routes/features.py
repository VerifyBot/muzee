import random
import re

import asyncspotify
import pydantic
from sanic import Request, json
from sanic_ext import validate

from server.context import Context
from server.decos import authorized, use_spotify
from .utils.actions import run_daily_smash, run_public_liked

from .utils.quick import to_user_now, to_local_time
from ..utils.spotify import MySpotifyClient

playlist_regex = r'(?:https:\/\/open\.spotify\.com\/playlist\/)?([a-zA-Z0-9]{22})(?:\?.+)?'


class GeneratePlaylistData(pydantic.BaseModel):
  topic: pydantic.constr(min_length=2, max_length=100)
  songs_count: pydantic.conint(ge=5, le=100)
  timezone_offset: pydantic.conint(ge=-12 * 60, le=12 * 60)


class ToggleDailySmashData(pydantic.BaseModel):
  enabled: bool
  update_at: pydantic.conint(ge=0, le=1440)
  songs_count: pydantic.conint(ge=5, le=100)
  timezone_offset: pydantic.conint(ge=-12 * 60, le=12 * 60)


class LanguageFilterData(pydantic.BaseModel):
  playlist: str = pydantic.Field(pattern=playlist_regex, min_length=22)
  keep_chars: pydantic.constr(min_length=1, max_length=150)
  timezone_offset: pydantic.conint(ge=-12 * 60, le=12 * 60)

  @pydantic.computed_field
  @property
  def playlist_id(self) -> str:
    return re.match(playlist_regex, self.playlist).groups()[0]


class TogglePublicLikedData(pydantic.BaseModel):
  enabled: bool
  timezone_offset: pydantic.conint(ge=-12 * 60, le=12 * 60)


@authorized
@validate(json=GeneratePlaylistData)
async def route_generate_playlist(request: Request, ctx: Context, body: GeneratePlaylistData):
  """
  Generate a playlist for the user based on the topic and the number of songs
  """

  # get the spotify client to generate the playlist
  sc = await ctx.spotify.get_client(user=ctx.user)

  print(await sc.get_me())

  try:
    topics = [topic.strip() for topic in body.topic.split(',')][:5]

    playlists = []

    for topic in topics:
      resp = await sc.get('search', q=topic, type='playlist', limit=5)
      playlists += resp['playlists']['items']

    total_songs_available = sum(p['tracks']['total'] for p in playlists)

    if total_songs_available == 0:
      return json({"error": "No songs found"})

    # shuffle results
    random.shuffle(playlists)

    songs_per_playlist = (body.songs_count // len(playlists)) + 15

    songs = set()

    for p in playlists:
      # get the songs
      offset = 0

      if (count := p['tracks']['total']) > songs_per_playlist:
        offset = random.randint(0, count - songs_per_playlist)

      resp = await sc.get(
        f'playlists/{p["id"]}/tracks',
        playlist_id=p['id'],
        limit=min(50, songs_per_playlist),
        fields='items(track(uri))',
        offset=offset
      )

      # add the songs
      songs |= set(it['track']['uri'] for it in resp['items'])

    songs = list(songs)
    random.shuffle(songs)
    songs = songs[:body.songs_count]

    generation_id = await ctx.db.update_stat(ctx.user, 'generated_playlists', +1)

    # generate the playlist
    resp = await sc.create_playlist(
      user=ctx.user.spotify_id,
      name=f"Generated #{generation_id} - {', '.join(topics)}",
      description=f"ðŸª„ Generated by Muzee @ {to_user_now(body.timezone_offset).strftime('%H:%M %d/%m/%Y')}."
    )

    # add the songs
    await sc.playlist_add_tracks(resp.id, *songs)

    # get img
    img_resp = await sc.get(f'playlists/{resp.id}', fields='images')

    result = dict(id=resp.id, name=resp.name, image=img_resp['images'][0]['url'], songs_count=len(songs))

    await ctx.db.log_event(ctx.user, 'generate_playlist', success=True, data=dict(
      request=body.dict(),
      result=result
    ))

    return json(result)

  finally:
    await sc.close()


@authorized
@validate(json=ToggleDailySmashData)
@use_spotify
async def route_toggle_daily_smash(request: Request, ctx: Context, body: ToggleDailySmashData, sc: MySpotifyClient):
  """
  Toggle the daily smash feature
  """

  smash_enabled = 'daily-smash' in ctx.user.enabled_features

  if smash_enabled == body.enabled:  # no change
    return json({"status": "ok", "image": await sc.get_image(ctx.user.ds_playlist)})

  # disable
  if not body.enabled:
    # remove the feature (remove daily-smash from the array of features)
    await ctx.db.disable_feature(ctx.user, 'daily-smash')
    return json({"status": "ok"})

  # enable
  await ctx.db.enable_feature(ctx.user, 'daily-smash')

  local_update_at = to_local_time(body.update_at, body.timezone_offset)

  # has a daily smash already?
  if ctx.user.ds_playlist:
    # need to update anything?
    if ctx.user.ds_songs_count != body.songs_count or ctx.user.ds_update_at != local_update_at:
      # need to update the playlist
      await ctx.db.pool.execute(
        "UPDATE users SET ds_songs_count = $1, ds_update_at = $2 WHERE id = $3",
        body.songs_count, local_update_at, ctx.user.id
      )

    return json({
      "status": "ok",
      "playlist": ctx.user.ds_playlist,
      "image": await sc.get_image(ctx.user.ds_playlist)
    })

  else:
    # create a new playlist ... update database
    # update context
    ctx.user.ds_songs_count = body.songs_count
    playlist = await run_daily_smash(ctx, create=True)
    ctx.user.ds_playlist = playlist

    await ctx.db.pool.execute(
      "UPDATE users SET ds_playlist = $1, ds_songs_count = $2, ds_update_at = $3 WHERE id = $4",
      playlist, body.songs_count, local_update_at, ctx.user.id
    )

    return json({
      "status": "ok", "playlist": ctx.user.ds_playlist,
      "image": await get_smash_image(ctx)  # need an updated version
    })


@authorized
@use_spotify
async def route_feature_details(request: Request, ctx: Context, sc: MySpotifyClient):
  """
  Get the details of a feature (like the daily smash)
  """

  feature = request.json.get('key')
  assert feature in ('daily-smash', 'public-liked'), "Route details for this feature is not implemented."

  if feature not in ctx.user.enabled_features:
    return json({"status": "disabled"})

  if feature == 'daily-smash':
    return json({
      "playlist": ctx.user.ds_playlist,
      "update_at": ctx.user.ds_update_at_minutes,
      "songs_count": ctx.user.ds_songs_count,
      "image": await sc.get_image(ctx.user.ds_playlist)
    })

  elif feature == 'public-liked':
    return json({
      "playlist": ctx.user.pl_playlist,
      "image": await sc.get_image(ctx.user.pl_playlist)
    })


@authorized
@validate(json=LanguageFilterData)
@use_spotify
async def route_language_filter(request: Request, ctx: Context, body: LanguageFilterData, sc: MySpotifyClient):
  """
  Generate a playlist for the user based on the topic and the number of songs
  """

  # get the spotify client to generate the playlist

  # playlist name?
  js = await sc.get(f"playlists/{body.playlist_id}", fields='name')
  pname = js['name']

  # get songs
  tracks = await sc.get_all_playlist_tracks(body.playlist_id, fields='items(track(uri, name))')
  keep_tracks = set()

  for track in tracks:
    name = track['track']['name']

    if any(c in body.keep_chars for c in name):
      keep_tracks.add(track['track']['uri'])

  # create a new playlist
  filtered_pname = f"Filtered {pname}"
  playlist = await sc.create_playlist(
    user=ctx.user.spotify_id,
    name=filtered_pname,
    description=f"ðŸª„ Filtered by Muzee @ {to_user_now(body.timezone_offset).strftime('%H:%M %d/%m/%Y')}."
  )

  await sc.add_tracks_to_playlist(playlist.id, list(keep_tracks))

  return json({
    "status": "ok",
    "id": playlist.id,
    "songs_count": len(keep_tracks),
    "image": await sc.get_image(playlist.id),
    "name": filtered_pname
  })


@authorized
@validate(json=TogglePublicLikedData)
@use_spotify
async def route_toggle_public_liked(request: Request, ctx: Context, body: TogglePublicLikedData, sc: MySpotifyClient):
  """
  Toggle the public liked feature
  """

  liked_enabled = 'public-liked' in ctx.user.enabled_features

  if liked_enabled == body.enabled:  # no change
    return json({"status": "ok", "image": await sc.get_image(ctx.user.pl_playlist)})

  # disable
  if not body.enabled:
    # remove the feature (remove public-liked from the array of features)
    await ctx.db.disable_feature(ctx.user, 'public-liked')
    return json({"status": "ok"})

  # enable
  await ctx.db.enable_feature(ctx.user, 'public-liked')

  # has a public liked already?
  if ctx.user.pl_playlist:
    return json({
      "status": "ok",
      "playlist": ctx.user.pl_playlist,
      "image": await sc.get_image(ctx.user.pl_playlist)
    })

  else:
    playlist = await run_public_liked(ctx, create=True)
    ctx.user.pl_playlist = playlist

    await ctx.db.pool.execute(
      "UPDATE users SET pl_playlist = $1 WHERE id = $2",
      playlist, ctx.user.id
    )

    return json({
      "status": "ok",
      "playlist": ctx.user.pl_playlist,
      "image": await sc.get_image(ctx.user.pl_playlist)
    })
